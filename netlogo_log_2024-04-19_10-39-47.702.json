[
  {"event":"start","timeStamp":"2024-04-19 10:39:47.703","eventInfo":{"studentName":"pjm","modelName":"C:\\Users\\paulj\\GDrive3\\GIT\\INTA-CSE-6742\\Project\\Code\\Project_Code_Gettysburg\\cemetery_hill_v0500.nlogo","version":"NetLogo 6.4.0","ipAddress":"172.21.16.1","loginName":"paulj","events":"[input-box, switch, slider, model-open, compile, stop, chooser, button, speed-slider, comment, command-center, start, widget-edit]"}}
, {"event":"model-open","timeStamp":"2024-04-19 10:39:47.703","eventInfo":{"name":"C:\\Users\\paulj\\GDrive3\\GIT\\INTA-CSE-6742\\Project\\Code\\Project_Code_Gettysburg\\cemetery_hill_v0500.nlogo"}}
, {"event":"compile","timeStamp":"2024-04-19 10:39:51.986","eventInfo":{"code":"breed [infantry squad]\ninfantry-own [health attack attack-range unit-speed mode goals army unit target-id target-dist\n  deploy-path-pos under-fire next-target cur-road-pos\n\n]\n\npatches-own [elevation road? road-marker ridge? cover orig-color tag]\n;confederates-own [health attack attack-range unit-speed]\n;unions-own [health attack attack-range unit-speed]\nglobals [color-min color-max\n  patch-data deployment-path max-elevation\n  union-start buford-deploy-1 ;buford-deploy-2\n  stored-deploy-paths union-start-pos\n  wave-1-confederates\n  union-orientation\n  confed-turn cemetary-hill total-unions-Buford personnel-per-turtle\n  ridge-toggle? Gettysburg-town-center town town-toggle?\n  south-health Chambersburg-road rr-bed-path cemetary-hill-set\n  max-health\n  infantry-default-speed column-limit\n  debug-mode? message-id message-coords\n  union-arrived-list never-been-on-road terminus\n  top-of-road\n  top-of-rr\n  confed-deployed-on-road\n  confed-deployed-on-rr\n]\n\n\n\nto load-patch-data\n;; Code from File Input Example and Grand Canyon\n\n  ; We check to make sure the file exists first\n  ;user-message \"Trace 1\"\n  ifelse ( file-exists? \"elev-by-rc.txt\" )\n  [\n    ; We are saving the data into a list, so it only needs to be loaded once.\n    set patch-data []\n    let max-values []\n\n    ; This opens the file, so we can use it.\n    file-open \"elev-by-rc.txt\"\n\n    ; Read in all the data in the file\n\n    while [ not file-at-end? ]\n    [\n      ; file-read gives you variables.  In this case numbers.\n      ; We store them in a double list (ex [[1 1 9.9999] [1 2 9.9999] ...\n      ; Each iteration we append the next three-tuple to the current list\n\n      set patch-data sentence patch-data (list (list file-read file-read file-read))\n\n    ]\n\n    ;if empty? patch-data [user-message \"empty list\"]\n\n    set max-elevation 123.148\n\n    let min-elevation 0\n    set color-min 0\n    set color-max 100\n\n\n    ; Done reading in patch information.  Close the file.\n    file-close\n  ]\n  [ user-message \"There is no file by that name in current directory!\" ]\n\n\n  ifelse ( file-exists? \"ChambersburgRoad-init-data.txt\" )\n  [\n    ; We are saving the data into a list, so it only needs to be loaded once.\n    ; This opens the file, so we can use it.\n    file-open \"ChambersburgRoad-init-data.txt\"\n\n    ; Read in all the data in the file\n    set deployment-path []\n    while [ not file-at-end? ]\n    [\n      ; file-read gives you variables.  In this case numbers.\n      ; We store them in a double list (ex [[1 1 9.9999] [1 2 9.9999] ...\n      ; Each iteration we append the next three-tuple to the current list\n      ;let line list file-read file-read\n      ;user-message \"Trace 4\"\n      ;ifelse (first line = \"lname\") []\n      ;show file-read\n      set deployment-path sentence deployment-path (list (list file-read file-read))\n    ]\n\n    ;if empty? patch-data [user-message \"empty list\"]\n\n\n    let min-elevation 0\n    ;set color-min min-elevation - ((color-max - min-elevation) \/ 10)\n    set color-min 0\n\n    ; Done reading in patch information.  Close the file.\n    file-close\n  ]\n  [user-message \"Road data file does not exist!\"]\n\n  ifelse ( file-exists? \"RR-Bed-init-data.txt\" )\n  [\n    ; We are saving the data into a list, so it only needs to be loaded once.\n    ; This opens the file, so we can use it.\n    file-open \"RR-Bed-init-data.txt\"\n\n    ; Read in all the data in the file\n    set rr-bed-path []\n    while [ not file-at-end? ]\n    [\n      ; file-read gives you variables.  In this case numbers.\n      ; We store them in a double list (ex [[1 1 9.9999] [1 2 9.9999] ...\n      ; Each iteration we append the next three-tuple to the current list\n      ;let line list file-read file-read\n      ;user-message \"Trace 4\"\n      ;ifelse (first line = \"lname\") []\n      ;show file-read\n      set rr-bed-path sentence rr-bed-path (list (list file-read file-read))\n    ]\n\n    ;if empty? patch-data [user-message \"empty list\"]\n\n    ; Done reading in patch information.  Close the file.\n    file-close\n  ]\n  [user-message \"RR bed data file does not exist!\"]\nend\n\nto show-ridges\n\n  ifelse not ridge-toggle?\n  [\n    ask patches [\n      if ridge?\n      [\n        set orig-color pcolor\n        set pcolor pink\n      ]\n    ]\n  ]\n  [\n      ask patches [\n      if ridge?\n      [\n        set pcolor orig-color\n      ]\n    ]\n  ]\n  set ridge-toggle? not ridge-toggle?\nend\n\nto show-town\n\n  ifelse not town-toggle?\n  [\n    ask town [\n        set orig-color pcolor\n        set pcolor green\n    ]\n  ]\n  [\n      ask town [\n        set pcolor orig-color\n    ]\n  ]\n  set town-toggle? not town-toggle?\nend\n\nto toggle-debug\n\n  set debug-mode? not debug-mode?\n\nend\n\n\n\nto initialize\n  clear-patches\n  clear-turtles ; if any, with settings set at good values, initialize should only need to be called once\n  ask patches[set road? false]\n  ask patches[set tag \"\"]\n  set stored-deploy-paths []\n  set buford-deploy-1 []\n  set personnel-per-turtle 5\n  let historical-Buford 2750\n  set ridge-elev-threshold .925\n  set ridge-toggle? false\n  set town-toggle? false\n  set south-health 0\n  set max-health 10\n  set infantry-default-speed .5\n  set column-limit 32\n  set debug-mode? false\n  set never-been-on-road 1000\n  set terminus -2\n  set confed-deployed-on-road 0\n  set confed-deployed-on-rr 0\n  set top-of-road list -50 37\n  set top-of-rr list -50 41\n\n\n\n\n  ask patches [set cover 1]\n\n  ask patches [ set ridge? false ]\n\n  set total-unions-Buford historical-Buford \/ personnel-per-turtle\n\n\n\n  load-patch-data\n  let buford-historical-deploy 6\n\n  set union-orientation get-angle item 0 deployment-path item buford-historical-deploy deployment-path\n  ;user-message word \"dep or:\" union-orientation\n  show-patch-data\n  ;ask patches[ set pcolor round (135 * elevation \/ color-max) ];[set pcolor round (135 * elevation \/ color-max)]\n    ;ifelse pxcor mod 10 = 0 and pycor mod 10 = 0\n    ;   [set pcolor red]\n   ask patches [ set pcolor scale-color brown elevation 0 100]\n\n  ask patches[ ifelse road?[set pcolor blue][set road-marker -1]]\n  ;user-message word \"item 7 \" item 7 deployment-path\n  set confed-turn item 7 deployment-path\n  ask patch first confed-turn last confed-turn\n  [\n    foreach range 69 [n -> ask patch-at-heading-and-distance union-orientation n [\n          set pcolor yellow\n          set road? true\n          set road-marker n\n          set tag \"Chambersburg\"\n          set cover 0\n      ]\n    ]\n  ]\n\n  foreach range length deployment-path\n  [\n    index ->\n    let zero-pos 7\n    if index > zero-pos\n    [\n      let x first item index deployment-path\n      let y last item index deployment-path\n      ask patch x y\n      [\n        set road? true\n          set road-marker -1 * (index - zero-pos)\n          set road? true\n          set tag \"Chambersburg\"\n          set cover 0\n      ]\n    ]\n  ]\n\n  foreach range length rr-bed-path\n  [\n    index -> if index < length rr-bed-path\n    [\n      let last-index length rr-bed-path - 1\n      let reversed-index last-index - index\n\n      let cur-pos item reversed-index rr-bed-path\n      let cur-patch patch first cur-pos last cur-pos\n      ask cur-patch [\n        set pcolor yellow\n          set road? true\n          set road-marker index\n          set tag \"RR\"\n          set cover 0\n      ]\n    ]\n  ]\n\n  let last-pos length deployment-path - 1\n  set cemetary-hill item last-pos deployment-path\n  set Gettysburg-town-center list ((first confed-turn) + 7) last confed-turn\n\n  let hill-x  first cemetary-hill\n  let hill-y  last cemetary-hill\n  let town-x  first Gettysburg-town-center\n  let town-y  last Gettysburg-town-center\n\n  ask patch hill-x hill-y\n  [\n    set road? true\n    set tag \"Chambersburg\"\n    set road-marker terminus\n  ]\n\n  ask patch town-x town-y\n  [\n    set road? true\n    set tag \"RR\"\n    set road-marker -1\n  ]\n\n\n  set Chambersburg-road patches with [tag = \"Chambersburg\"]\n  set rr-bed-path patches with [tag = \"RR\"]\n\n  ;user-message word \"Road init: \" Chambersburg-road\n  let center-patch patch first Gettysburg-town-center last Gettysburg-town-center\n  set town patches with [distance center-patch <= 8]\n  ask town [ set cover 8]\n  set cemetary-hill-set patches with [distance patch first cemetary-hill last cemetary-hill < 4]\n  ask cemetary-hill-set [set cover 10]\n\n\nend\n\nto show-patch-data\n  ifelse ( is-list? patch-data )\n    [foreach patch-data [ three-tuple -> ask patch first three-tuple item 1 three-tuple [ set elevation last three-tuple ] ] ]\n    [ user-message \"You need to load in patch data first!\" ]\n\n  foreach deployment-path [ two-tuple -> ask patch first two-tuple last two-tuple [set road? true]]\n\n  let deploy-index 0\n  let half-total round (total-unions-Buford \/ 2)\n  let patch-limit 8  ; 8 agents per path, i.e. 40 over 65 square meter patch\n\n  let quit? false\n  while[not quit?] [\n    ;user-message word \"setting up deploy paths for index \" union-start-pos\n    let cur-start item deploy-index deployment-path\n    let start-above list first cur-start (last cur-start + 2)\n    ;user-message (word \"start-above\" start-above)\n    let start-below list first cur-start (last cur-start - 2)\n\n    ;user-message (word \"start-above\" start-above)\n    set buford-deploy-1 []\n    get-defensive-line start-above half-total patch-limit\n    ;user-message word \"after get-def 1 \" buford-deploy-1\n    get-defensive-line start-below half-total patch-limit\n\n    let path-1 []\n    foreach buford-deploy-1 [v -> set path-1 lput v path-1]\n\n    set stored-deploy-paths lput path-1 stored-deploy-paths\n    ;user-message word \"length of stored-deploy-paths: \" length stored-deploy-paths\n    ;user-message word \"last deployment path: \" last stored-deploy-paths\n    set deploy-index deploy-index + 1\n    if deploy-index = length deployment-path [set quit? true]\n  ]\n\n  ;user-message word \"deployment path 0 \" item 0 stored-deploy-paths\n  ;5user-message word \"deployment path 1 \" item 1 stored-deploy-paths\n  ;foreach stored-deploy-paths [nd -> user-message word \"cur path len: \" length nd]\n\n  let pairs-2 [[[1 -1] [1 1]] [[1 0]  [0 1]] [[1 0]  [0 -1]] [[0 1][0 -1]] [[1 -1][-1 1]]]\n  ask patches [\n\n    if find-ridge  [\n      set ridge? true\n      set cover 8\n      ;set pcolor pink\n    ]\n\n\n  ]\n  display\nend\n\nto trace[level msg]\n\n  if debug-mode? or level = 0\n  [\n    ifelse debug-set = 0 or debug-set = level or level = 0 [\n      show msg\n      let continue user-yes-or-no? (word msg \" \" \"Continue debug?\")\n        if not continue [\n          set debug-mode? false\n        ]\n    ]\n    [\n      if debug-mode? [show msg]\n    ]\n  ]\nend\n\nto-report find-ridge\n  let pairs-1 [\n    [  [[1 1] [1 0] [1 -1]] [[-1 1] [-1 0] [-1 -1]] ] ; front row vs back\n    [  [[1 -1] [0 -1] [-1 -1]]  [[1 1] [0 1] [-1 -1]] ] ; left row vs right\n    ;[  [[1 1] [1 0] [0 1]] [[-1 -1] [-1 0] [0 -1]] ] ; split along diagonal\n    ;[  [[1 -1] [1 0] [0 -1]] [[-1 1] [-1 0] [0 1]] ] ; split along the other diagonal\n  ]\n\n;    if pxcor = -12 and pycor = 27\n;    [\n;     set debug? true\n;    ]\n    let cur-row 0\n    while [cur-row < length pairs-1][\n      let row-pair item cur-row pairs-1\n      let my-elev elevation\n      let s1 patches at-points first row-pair\n      let elev1 s1 with [elevation < ridge-elev-threshold * my-elev]\n      trace 2 word \"s1 = \" s1\n      ;if debug-set = 1 or debug-set = 2 [user-message word \"elev1 = \" elev1]\n      if any? elev1\n      [\n        let s2 patches at-points last row-pair\n        let elev2 s2 with [elevation < my-elev]\n        if any? elev2\n        [\n          report true\n        ]\n      ]\n      set cur-row cur-row + 1\n   ]\n\n  report false\nend\n\nto setup\n  ;clear-all\n  ;user-message deployment-path\n  clear-turtles\n  clear-all-plots\n  set debug-mode? false\n  set union-arrived-list []\n\n  ask infantry [set under-fire 0\n    set next-target nobody\n  ]\n  let center-patch patch first Gettysburg-town-center last Gettysburg-town-center\n  set town patches with [distance center-patch <= 10]\n\n  set union-start-pos -1\n  ifelse start-pos-choice = -1 [\n    set union-start-pos random length deployment-path\n  ]\n  [\n    set union-start-pos start-pos-choice\n  ]\n\n  set union-start item union-start-pos deployment-path\n  ;user-message union-start\n  foreach deployment-path [pos -> ask patch first pos last pos  [set pcolor blue]]\n  ask patch first union-start last union-start [set pcolor orange]\n\n  ;setup-confederates-2\n  setup-unions\n  reset-ticks  ; Resets the tick counter for the simulation\nend\n\n\nto add-to-road[total-to-deploy in-army in-unit start-of-route]\n\n  ;trace 0 \"adding to road\"\n  let cur-total count infantry with [army = in-army and unit = in-unit]\n  let set-on-top turtles-on patch first start-of-route last start-of-route\n  let filtered-set set-on-top with [army = in-army and unit = in-unit]\n  let cur-count count filtered-set\n  let unit-pcolor 0\n\n  if in-army = \"South\" [\n      set unit-pcolor red\n  ]\n  if in-army = \"North\" [\n      set unit-pcolor blue\n  ]\n\n  if cur-total < total-to-deploy and cur-count < column-limit\n    [\n      let cur-to-make column-limit - cur-count\n      if start-of-route = top-of-rr\n      [\n        set confed-deployed-on-rr confed-deployed-on-rr + cur-to-make\n      ]\n      if start-of-route = top-of-road\n      [\n        set confed-deployed-on-road confed-deployed-on-road + cur-to-make\n      ]\n      create-infantry  cur-to-make [\n        set color unit-pcolor\n        set army in-army\n        set unit in-unit\n        set health max-health\n        set attack 2\n        set attack-range 5\n        set unit-speed infantry-default-speed\n        set mode \"M\"\n        set deploy-path-pos -1\n        set under-fire 0\n        set cur-road-pos never-been-on-road\n\n        setxy first start-of-route last start-of-route\n      ]\n  ]\n\n\nend\n\nto add-confederates-phase-1\n  let num-confederates (7600 \/ 5)  ; The total number of Confederate agents you plan to create\n\n  let max-xcor (max-pxcor \/ 6)  ; Maximum x-coordinate limit for the upper left quadrant\n  let max-ycor (max-pycor \/ 5)  ; Maximum y-coordinate limit for the upper left quadrant\n\n  let start-x1 -50\n  let start-y1 37\n  let end-x1 -40\n  let end-y1 30\n\n  let start-x2 -25\n  let start-y2 45\n  let end-x2 -20\n  let end-y2 50\n\n\n  let to-deploy-on-road round(num-confederates \/ 2)\n  let to-deploy-on-rr to-deploy-on-road ; splitting forces equally here\n\n  if confed-deployed-on-road < to-deploy-on-road[\n    add-to-road to-deploy-on-road \"South\" \"RoadWave1\" top-of-road\n  ]\n  if confed-deployed-on-rr < to-deploy-on-rr [\n    add-to-road to-deploy-on-rr \"South\" \"RRWave1\" top-of-rr\n  ]\n\n\nend\n\nto-report in-bounds [cur aleft aright]\n  if cur < 0 [user-message \"cur < 0 \"]\n\n  let left-okay? false\n  if aleft < 0\n  [\n    set cur cur - 360\n  ]\n\n  set left-okay? true\n  if aleft = 270 [\n    if cur <= 360 and cur > aleft [report true]\n    if cur >= 0 and cur <= aright [report true]\n  ]\n\n\n  if aright = 270 [\n    if cur < 270 and cur >= aleft [report true]\n  ]\n\n   let msg (word \"left > cur < right \" aleft \": \" cur \": \" aright)\n   ;user-message msg\n\n  report false\nend\n\nto-report in-line-of-sight[possible-target]  ;; walker procedure\n  let dist 1\n  let a1 0\n  ;let c color\n  let last-patch patch-here\n  ;; iterate through all the patches\n  ;; starting at the patch directly ahead\n  ;; going through MAXIMUM-VISIBILITY\n\n  ;user-message (word possible-target \" x:\" [xcor] of possible-target \" y:\" [ycor] of possible-target)\n  face possible-target\n  while [dist <= 10] [\n    let p patch-ahead dist\n    ;; if we are looking diagonally across\n    ;; a patch it is possible we'll get the\n    ;; same patch for distance x and x + 1\n    ;; but we don't need to check again.\n    if p != last-patch [\n      ;; find the angle between the turtle's position\n      ;; and the top of the patch.\n      let a2 atan dist (elevation - [elevation] of p)\n      ;; if that angle is less than the angle toward the\n      ;; last visible patch there is no direct line from the turtle\n      ;; to the patch in question that is not obstructed by another\n      ;; patch.\n      ifelse a1 < a2\n      [\n        ;user-message get-print-string (list \"targ coords\" [xcor] of possible-target [ycor] of possible-target) 3\n        ;user-message get-print-string (list \"visible patch coords \" [pxcor] of p  [pycor] of p) 3\n        if round [xcor] of possible-target = [pxcor] of p\n           and round [ycor] of possible-target = [pycor] of p\n        [ report true]\n      ]\n      [\n        set a1 a2\n      ]\n      set last-patch p\n    ]\n    set dist dist + 1\n  ]\n  report false\nend\n\n\n\nto-report get-angle[coord1 coord2] ; angle measure clockwise from north = 0\n  let xrun  first coord1 - first coord2\n  let yrise  last coord1 - last coord2\n\n  report atan xrun yrise\nend\n\nto-report convert-to-geometric[a]\n  report (90 - a) mod 360\nend\n\nto-report get-geometric-angle[coord1 coord2] ; geometric angle, where angles measured from horizontal x-axis\n  let xrun  first coord1 - first coord2\n  let yrise  last coord1 - last coord2\n\n  report convert-slope-to-geometric-angle xrun yrise\nend\n\nto-report convert-slope-to-geometric-angle[x y]\n  report convert-to-geometric atan x y\nend\n\nto get-defensive-line[start-pt num-agents patch-limit]\n\n  let cur-path-pos  start-pt\n  let cnt num-agents\n  let rem cnt\n  let north? true\n  if length buford-deploy-1 > 0 [set north? false]\n\n  let main-dir 0\n  let a-left 0\n  let a-right 0\n  ifelse north?[\n    set main-dir union-orientation - 270\n    set a-left 270\n    set a-right 90\n  ]\n  [\n    set main-dir union-orientation - 90\n    set a-left 90\n    set a-right 270\n  ]\n\n  while [rem > 0]\n  [\n    let cur-patch patch first cur-path-pos last cur-path-pos\n    ask cur-patch [\n      ;user-message word \"len \" length max-n-of 8 neighbors [elevation]\n      let close-p neighbors\n      ;user-message max-n-of 8 neighbors [elevation] user-message (word \"highest elev:\" close-p)\n      ;let p-list [self] of close-p\n      let elevs sort-by [[p1 p2] -> [elevation] of p1 > [elevation] of p2] close-p\n\n      let test-out []\n      ; user-message (word \"for elev \" [elevation] of ptch \" \" [pxcor] of ptch \" \" [pycor] of ptch )\n      let found? false\n      let elev-pos 0\n      let a-cur -1\n      while[not found? and elev-pos < length elevs]\n      [\n        let high-patch item elev-pos elevs\n        let high-coords list [pxcor] of high-patch [pycor] of high-patch\n        set a-cur get-angle high-coords list pxcor pycor\n\n        ifelse in-bounds a-cur a-left a-right\n        [\n          if not member? high-coords buford-deploy-1\n          [\n            set buford-deploy-1 sentence buford-deploy-1 (list (list first high-coords last high-coords))\n            set found? true\n            set cur-path-pos high-coords\n          ]\n        ]\n        [\n\n        ]\n        if not found?\n        [\n            set elev-pos elev-pos + 1\n        ]\n      ]\n\n      if not found?[\n        user-message (word \"didn't find it for cur-patch: \" cur-patch \" start-pt: \" start-pt)\n        let high-coords list [pxcor] of cur-patch [pycor] of cur-patch\n        while [not member? high-coords buford-deploy-1][\n            set high-coords list (first high-coords - 1) (last high-coords - 1)\n        ]\n        set buford-deploy-1 sentence buford-deploy-1 (list (list first high-coords last high-coords))\n\n      ]\n\n    ]\n    set rem (rem - patch-limit)\n  ]\nend\n\n\n\nto deploy-to-path[num-agents patch-limit path-list]\n  let cur-path-pos 0\n  let rem  num-agents\n  ;user-message word \"deploy path list \" path-list\n  ;user-message word \"path-list \" path-list\n  while [rem > 0]\n  [\n    let cur-troop-pos item cur-path-pos path-list\n\n    create-infantry patch-limit [\n\n      setxy first cur-troop-pos last cur-troop-pos; Set the position of the Union agent\n\n      set color blue\n      set health max-health\n      set attack 3\n      set attack-range 5\n      set unit-speed 3\n      set army \"North\"\n      set unit \"Buford\"\n      set mode \"D\"\n      set goals []\n      set target-id -1\n      set target-dist 0\n      set message-id -1\n      set message-coords nobody\n      set deploy-path-pos cur-path-pos\n      set cur-road-pos never-been-on-road\n    ]\n\n    set cur-path-pos cur-path-pos + 1\n    set rem rem - patch-limit\n  ]\n\n;  let cur-unit-id 1\n;  foreach range cur-path-pos [\n;    pn ->\n;    ;let n-on-pos count infantry with [deploy-path-pos = np]\n;    foreach sort infantry with [deploy-path-pos = pn]\n;    [\n;      cur-agent ->\n;      ask cur-agent[\n;        set unit-id cur-unit-id\n;      ]\n;      set cur-unit-id cur-unit-id + 1\n;\n;    ]\n;  ]\n\nend\n\nto setup-unions\n\n  let center-x 0  ; Center x-coordinate\n  let center-y (max-pycor \/ 4) - 10  ; Center y-coordinate, adjusted lower than Confederates\n  let radius 2.5; Radius of the circular formation\n  let patch-limit 8 ; low density to reproduce Buford deployment\n\n  ;user-message \"Calling get def 1st time\"\n\n  let cur-deploy-path-index union-start-pos\n  ;user-message word \"getting deploy path at pos \" cur-deploy-path-index\n  set total-unions-Buford 10\n  deploy-to-path total-unions-Buford patch-limit item cur-deploy-path-index stored-deploy-paths\n  ask infantry with [army = \"North\"]\n  [\n    let saved-heading [heading] of self\n    uphill cover\n    set heading saved-heading\n  ]\nend\n\nto-report get-print-string[ inputs prec ] ; expecting list\n  let res-str \"\"\n  ifelse length inputs = 2\n  [\n    report word item 0 inputs item 1 inputs\n  ]\n  [\n    foreach range length inputs\n    [\n      index ->\n        let cur item index inputs\n        ifelse index = 0 [\n        ifelse is-number? cur\n        [\n          set res-str word \"\" precision cur prec\n          set res-str word res-str \" \"\n        ]\n        [\n          set res-str word \"\" cur\n          set res-str word res-str \" \"\n        ]\n      ]\n      [\n        ifelse is-number? cur\n        [\n          set res-str word res-str precision cur prec\n          set res-str word res-str \" \"\n        ]\n        [\n          set res-str word res-str cur\n          set res-str word res-str \" \"\n        ]\n      ]\n\n    ]\n  ]\n  report res-str\nend\n\nto-report get-unit-speed[cur-unit]\n\n  let targ-patch [next-target] of cur-unit\n  if [next-target] of cur-unit = 0 or [next-target] of cur-unit = nobody\n  [\n    set targ-patch patch-ahead 1\n  ]\n  if targ-patch = nobody\n  [\n    report 0\n    ;show word \"!!! \" [who] of cur-unit\n    ;inspect cur-unit\n    ;inspect [next-target] of cur-unit\n    ;trace 0 \"targ patch is nobody!!!!\"\n\n  ]\n\n  let cur-pos list [xcor] of cur-unit [ycor] of cur-unit\n  let cur-elevation [elevation] of patch first cur-pos last cur-pos\n  let targ-pos list [pxcor] of targ-patch [pycor] of targ-patch\n  let targ-elevation [elevation] of targ-patch\n  let elevation-difference cur-elevation - targ-elevation\n  let targ-patch-pop count turtles-on targ-patch\n\n  if targ-patch-pop > column-limit [report 0]\n\n  let base-speed [unit-speed] of cur-unit\n  if debug-set = 1 or debug-set = 3 [user-message word \"base-speed: \" base-speed]\n  let cur-speed base-speed\n  if debug-set = 1 or debug-set = 3 [user-message word \"cur-speed b4: \" cur-speed]\n\n  set cur-speed cur-speed * ([health] of cur-unit) \/ max-health\n\n  let res-speed cur-speed\n  let slope-a convert-slope-to-geometric-angle 65 elevation-difference ; 65~ path length in meters\n  ifelse elevation-difference > 0\n  [\n    if slope-a > 30 ; set stumble factor\n    [\n      set res-speed res-speed * .8\n    ]\n    ;trace 3 word \"res-speed down: \" res-speed\n  ]\n  [\n    set res-speed res-speed * cos slope-a\n    trace 3 word \"res-speed up: \" res-speed\n  ]\n\n  if res-speed > base-speed[ user-message word \"Something fishy with speed, res speed: \" (res-speed \/ base-speed) ]\n  ;trace 3 word \"respeed\" res-speed\n  report res-speed\nend\n\nto follow-path[actor path-to-follow]\n  let test [road?] of patch-here\n   ;user-message word \"double \" double\n  trace 2 \"top of follow-path\"\n  trace 2 word \"test \" test\n  let next nobody\n  ; should be RoadWave1 unit\n  let cur-marker [road-marker] of patch-here\n  let next-road-marker cur-marker - 1 ; neg inf\n  ifelse test\n  [\n    set next one-of patches with [road? and road-marker = next-road-marker and tag = path-to-follow]\n\n    if next != nobody\n    [\n      trace 2 (word \"found patch is \" next \" rm : \" [road-marker] of next)\n    ]\n  ]\n  ; not on road\n  [\n    trace 2 word \"follow-path not-on-path logic \" [who] of actor\n    ifelse [cur-road-pos] of actor = never-been-on-road\n    [\n      set next min-one-of patches with [tag = path-to-follow] [distance myself ]\n    ]\n    [\n       set next nobody\n    ]\n  ]\n\n  while [next = nobody and cur-marker >= terminus ] ;-2 is cemetary hill\n  [\n      ;trace 2 word \"follow-path  3aba2 \" [who] of actor\n      set next-road-marker next-road-marker - 1\n      ifelse next-road-marker > terminus ; this will be town center for RR, after should go to c-hill\n      [\n        set next one-of patches with [road? and road-marker = next-road-marker and tag = path-to-follow]\n      ]\n      [ ;; should only be valid for terminus == -2\n        set next one-of patches with [road? and road-marker = next-road-marker and tag = \"Chambersburg\"]\n      ]\n   ]\n\n  ask actor [\n    set cur-road-pos next-road-marker\n    set next-target next\n  ]\n  if [next-target] of actor = 0 or next = nobody\n  [\n    trace 2 ( word \"trace follow-path next-target: \" [next-target] of actor \" who \" [who] of actor )\n  ]\n\nend\nto-report get-patch-population-next-door [actor cur-heading]\n    let targ-patch patch-at-heading-and-distance cur-heading 1\n    report get-patch-population actor targ-patch\nend\n\nto-report get-patch-population [actor targ-patch]\n    if targ-patch = nobody\n    [\n       report 50000 ; infinity\n    ]\n    let pop-targ turtles-on targ-patch\n    if pop-targ != nobody\n    [\n      report count pop-targ\n    ]\n    report 50000 ;i.e. infinity\nend\n\n\nto confed-move\n  let actor self\n  let next nobody\n ;set debug-mode? true\n  if [army] of actor = \"North\"\n  [stop]\n\n  ;user-message \"trace confed-move\"\n;  if [health] of actor < .9 * max-health\n;  [\n;    ask actor [uphill cover]\n;    ;show word \"trace 2a \" [who] of actor\n;  ]\n;\n  if [under-fire] of actor = 0 and [mode] of actor = \"E\"\n  [\n    ask actor [set mode \"M\"]\n    stop\n  ]\n\n  if [under-fire] of actor > 0\n  [\n    ask actor [\n      set under-fire under-fire - 1\n    ]\n    let nearest-enemy min-one-of infantry with [army = \"North\"] [distance actor]\n    face nearest-enemy\n    let enemy-heading [heading] of actor\n    let heading-1 (enemy-heading - 90) mod 360\n    let heading-2 (enemy-heading + 90) mod 360\n\n    let targ-patch-pop-1 get-patch-population-next-door actor heading-1\n    let targ-patch-pop-2 get-patch-population-next-door actor heading-2\n\n    let new-heading 0\n    ifelse targ-patch-pop-1 < targ-patch-pop-2\n    [\n      set new-heading heading-1\n    ]\n    [\n      set new-heading heading-2\n    ]\n    ;show word \"trace 2c \" [who] of actor\n     ask actor [\n        set heading new-heading\n\n        ask actor [\n        set next-target patch-ahead 1]\n        let cur-speed get-unit-speed actor\n        forward cur-speed\n        message-by-dir actor\n        message-by-dir actor\n        set heading enemy-heading\n    ]\n\n    ask actor [ set mode \"E\" ]\n    stop\n  ]\n\n  if mode = \"M\"\n  [\n    ;show word \"trace 2 actor = \" actor\n\n      ;max-one-of turtles [distance myself\n\n    if [unit] of actor = \"RoadWave1\"[\n      ;show word \"proc road:\" actor\n      follow-path actor \"Chambersburg\"\n    ]\n    if [unit] of actor = \"RRWave1\"[\n      ;show word \"proc RR:\" actor\n      follow-path actor \"RR\"\n    ]\n    trace 2 ( word \"trace 3c next-target: \" [next-target] of actor\" who \" [who] of actor )\n\n  ]\n\n;  if actor = nobody or next = nobody\n;  [\n;        user-message (word \"!!!! actor\/next \" actor next)\n;  ]\n\n  ;show word \"trace 02 \" [who] of actor\n  ask actor [\n    ;trace 2 ( word \"trace 10 next-target: \" [next-target] of actor \" who \" [who] of actor )\n    let cur-speed get-unit-speed actor\n    ifelse next-target = nobody\n    [\n      ;trace 0 (word \"next-target is nobody cur-unit \" self \" cur patch \" patch-here \" mode \" [mode] of actor \" uf \" [under-fire] of actor)\n    ]\n    [\n      face next-target\n      forward cur-speed\n      set next-target nobody\n    ]\n\n    ;trace 4 (word \"next: \" next \" speed: \" cur-speed \" base speed\" [unit-speed] of actor)\n  ]\n\nend\n\nto go\n\n  add-confederates-phase-1\n\n\n  ask infantry with [ army = \"North\" ] [\n    move-to-defend infantry with [army = \"South\"]\n    engage infantry with [army = \"South\"]\n    set south-health sum [health] of infantry with [army = \"South\"]\n    ;user-message word \"s health: \" south-health\n  ]\n\n  ; Increment Confederate engage tick counter and global tick counte\n  ask infantry with [army = \"South\"] [\n    confed-move\n    engage infantry with [army = \"North\"]\n  ]\n  if count infantry with [army = \"South\"] < .5 * wave-1-confederates [\n    user-message \"Simulation ends, more than 50% confederate casualties.\"\n    stop\n  ]\n\n  if count infantry with [army = \"North\"] <= 0 [\n    user-message \"Simulation ends, union forces destroyed.\"\n    stop\n  ]\n\n  if ticks > 360\n  [\n    user-message \"Reynolds reinforcements arrived.\"\n    stop\n  ]\n\n\n  tick\nend\n\n;to move-2\n;\n;\n;  let hill-dist 22\n;\n;  ifelse distance patch first cemetary-hill last cemetary-hill < 22\n;  [\n;    face patch first cemetary-hill last cemetary-hill\n;    forward .5\n;  ]\n;  [\n;    face patch first turn last turn\n;    forward .5\n;  ]\n;\n;\n;\n;end\n\n;to move-towards-union\n;  ; Ensure there are Union agents before proceeding\n;  if count infantry with [army = \"North\"] > 0 [\n;    ; Central y-coordinate as a reference point\n;    let center-y (min-pycor \/ 2)\n;\n;    ; Calculate the average position (centroid) of Union forces\n;    let union-center-x mean [xcor] of infantry with [army = \"North\"]\n;    let union-center-y mean [ycor] of infantry with [army = \"North\"]\n;\n;    ; Generate a random target point across the width and below the current position\n;    let random-target-x (min-pxcor + random (2 * max-pxcor))\n;\n;\n;    ;let random-target-y center-y + random-float ((min [ycor] of confederates) - center-y)\n;    let last-pos length deployment-path - 1\n;    let cemetary-hill item last-pos deployment-path\n;\n;    ; Ensure the target doesn't go too low or off-screen\n;    ;if random-target-y < center-y [set random-target-y center-y]\n;\n;    ; Calculate a weighted target point, partially oriented towards Union centroid\n;    let weight 0.7  ; Adjust the weight for more or less orientation towards Union\n;    let target-x (weight * union-center-x + (1 - weight) * first cemetary-hill)\n;    let target-y (weight * union-center-y + (1 - weight) * last cemetary-hill)\n;\n;    ; Adjust heading towards the weighted target position\n;    set heading towardsxy target-x target-y\n;\n;    ; Move forward with randomness in speed to simulate terrain and uncertainty\n;    forward 0.5 + (random-float 0.2)  ; Adjusted for noticeable variability\n;  ]\n;end\n\n\n\nto message-by-dir [actor]\n  let cur-set infantry with [army = [army] of actor and distance myself < [attack-range] of actor]\n  if cur-set != nobody\n  [\n    ask cur-set [\n      if message-id != -1\n      [\n        set message-id [who] of actor\n        set message-coords list [xcor] of actor [ycor] of actor\n      ]\n    ]\n  ]\n\nend\n\nto message-direct [actor recipients targ-patch]\n  if recipients != nobody\n  [\n    ask recipients [\n      set message-id [who] of actor\n      set message-coords list [pxcor] of targ-patch [pycor] of targ-patch\n    ]\n  ]\nend\n\nto move-to-defend[enemy-breed]\n  let actor self  ; Store the current agent as 'actor' for clarity and to avoid misuse of 'myself'\n  if [army] of actor = \"South\"\n  [stop]\n\n  ;let debug-proc false\n\n  ;if any? infantry with [mode = \"DF\"]\n  ;[ user-message word \"df mode \" infantry with [mode = \"DF\"]]\n  if [health] of actor < .9 * max-health\n  [\n    ask actor [\n      let near-cover max-one-of neighbors [cover]\n      ifelse [cover] of near-cover = [cover] of actor\n      [\n        ; climb instead\n        uphill elevation\n      ]\n      [\n        uphill cover\n      ]\n\n    ]\n  ]\n  ask actor [ set under-fire under-fire - 1]\n  if [under-fire] of actor = 0 and [mode] of actor = \"E\"\n  [\n    ask actor [\n      set mode \"D\"\n    ]\n  ]\n\n  if [health] of actor < 3\n  [\n    let c-hill patch first cemetary-hill last cemetary-hill\n    let c-hill-dist distance c-hill\n    if not member? actor union-arrived-list and distance c-hill < 2\n    [\n      while [get-patch-population actor patch-here > [cover] of patch-here]\n        [\n          ask actor [\n            set heading random 360\n            forward 1 ]\n        ]\n\n      set union-arrived-list lput actor union-arrived-list\n\n      stop\n    ]\n\n\n    face c-hill\n    ask actor[\n      set next-target patch-ahead 1\n    ]\n    ;let cur-speed get-unit-speed actor\n    forward .5\n    stop\n  ]\n\n  if [mode] of actor = \"D\"\n  [\n      set color blue\n      let my-enemy min-one-of enemy-breed [distance actor]\n      if my-enemy != nobody\n      [face my-enemy]\n      if message-id != -1\n      [\n        ask actor [set mode \"DF\"]\n      ]\n    stop\n  ]\n\n\n   if [mode] of actor = \"DF\"\n   [\n    set mode \"D\"\n    set color green\n    ;show word \"got a moving message \" [who] of actor\n    let saved-heading heading\n    let move-targ patch first message-coords last message-coords\n    if move-targ != nobody\n    [\n      face move-targ\n      let next-p patch-ahead 1\n      ifelse next-p = nobody\n      [\n        ;trace 0 (word \"next p \" [pxcor] of patch-here \":\" [pycor] of patch-here)\n      ]\n      [\n        ask actor [\n          set next-target next-p\n          forward get-unit-speed actor\n          set heading saved-heading\n        ]\n\n      ]\n    ]\n\n    let next-bud nobody\n    ;let redeploy-set max-n-of 2 infantry with [army = \"North\"][distance actor]\n    message-by-dir actor\n    stop\n   ]\n\n  if [mode] of actor = \"RD\"\n  [\n    ask actor\n    [\n      face patch first message-coords last message-coords\n      forward get-unit-speed actor\n    ]\n\n  ]\n\n\nend\n\n\nto engage [enemy-breed]\n  let actor self  ; Store the current agent as 'actor' for clarity and to avoid misuse of 'myself'\n  ;let target min-one-of enemy-breed [distance actor]\n  let target one-of enemy-breed in-cone attack-range 150\n  let seen? target != nobody\n  ;user-message word \"vision test \" seen?\n  let my-mode [mode] of actor\n  ifelse not seen?\n  [\n    if [army] of actor = \"North\"\n    [\n      set color blue\n      set mode \"D\"\n    ]\n    if [army] of actor = \"South\"\n    [\n      set color red\n      set mode \"M\"\n    ]\n\n    stop\n  ]\n  [\n    ;let in-sight? in-line-of-sight target\n    let in-sight? true\n    if in-sight?\n    [\n      if target != nobody and distance target < [attack-range] of actor\n      [\n        ;let engaged? [who] of target = [target-id] of actor\n        let dist-delta 0\n        let follow? false\n        let cur-dist distance target\n        set dist-delta cur-dist - [target-dist] of actor\n        if dist-delta > 0 [set follow? true]\n\n\n        ask actor [  ; Ensure 'ask' is correctly scoped to use 'actor' not 'myself'\n          set mode \"E\"\n          if [army] of actor = \"North\"\n            [set color orange]\n          if [army] of actor = \"South\"\n            [set color pink]\n\n          set target-id [who] of target\n          set target-dist cur-dist\n          fight target\n        ]\n\n        if [army] of actor = \"North\"\n          [\n            set target min-one-of enemy-breed [distance myself]\n            ask actor\n            [\n              ;message-by-dir actor\n              ifelse target != nobody\n              [\n\n                ;message-by-dir actor\n                set target min-one-of enemy-breed [distance myself]\n\n                set heading [heading] of target\n                set next-target patch-ahead 1\n                let next-target-2 patch-ahead 2\n\n                forward get-unit-speed actor\n                face target\n\n                let available-set infantry with [army = [army] of actor and mode = \"D\"]\n                let available count available-set\n                if available > 0 and available <= 2\n                [\n                  let redeploy-set max-n-of available available-set[distance myself]\n                  if redeploy-set != nobody [\n                    ask redeploy-set [\n                      set mode \"RD\"\n                  ]\n                ]\n               ;trace 0 word \"redeploying \" redeploy-set\n                message-direct actor redeploy-set next-target-2\n\n                ]\n\n              ]\n              [\n                trace 0 \"target in follow logic is nobody\"\n              ]\n            ]\n          ]\n     ]\n   ]\n ]\n\n\nend\n\nto-report get-effective-cover[target ]\n  let my-elevation [elevation] of patch xcor ycor\n  let targ-pos list [xcor] of target [ycor] of target\n  let targ-patch patch first targ-pos last targ-pos\n  let patch-cover [cover] of targ-patch\n  let targ-elevation [elevation] of targ-patch\n  let elevation-difference my-elevation - targ-elevation\n  let dist-meters (distance target * 65)\n  let slope-a convert-slope-to-geometric-angle dist-meters elevation-difference\n\n\n  let slope-factor 1 + .5 * tan slope-a\n\n  report patch-cover * slope-factor\nend\n\nto fight [target]\n  let actor self\n  let attack-value [attack] of myself\n  let dist-meters (distance target * 65)\n  let targ-pos list [xcor] of target [ycor] of target\n  let targ-patch patch first targ-pos last targ-pos\n  let targ-mode [mode] of target\n  let targ-patch-pop count turtles-on targ-patch\n\n\n  let my-attack-range [attack-range] of myself * 65\n  ; Calculate the attack success probability based on elevation difference\n\n\n  let effective-cover get-effective-cover target\n\n  let success-prob .05\n  if dist-meters < 1 * my-attack-range [set success-prob .3]\n  if dist-meters < .8 * my-attack-range [set success-prob .4]\n  if dist-meters < .6 * my-attack-range [set success-prob .5]\n  if dist-meters < .4 * my-attack-range [set success-prob .6]\n  if dist-meters < .2 * my-attack-range [set success-prob .7]\n  if dist-meters < .1 * my-attack-range [set success-prob .8]\n\n  let cover-factor .2 ; reduction of success by availability of cover\n  ifelse targ-mode = \"M\"\n  [\n    set cover-factor 1  ; no coverage while moving\n  ]\n  [\n    if targ-patch-pop > effective-cover;\n    [\n      let not-covered targ-patch-pop - [cover] of targ-patch\n      let prob-not-covered not-covered \/ targ-patch-pop\n      if random-float 1 < prob-not-covered [set cover-factor 1]\n    ]\n  ]\n  ask target [set under-fire under-fire + 1] ;under-fire\n\n  let saved-prob success-prob * 100\n  set success-prob (success-prob * cover-factor) * 100\n\n  ;user-message (word \"before\/after prob \" saved-prob \" \" success-prob)\n  ;user-message (word \"prob: \" success-prob \" slope: \" slope \" cover: \" cover-factor \" meters: \" dist-meters)\n\n  ; success probability is within the valid range (0 to 100)\n\n  ; Check if the attack is successful based on the success probability\n\n  if random 100 < success-prob [\n    ask target [\n      set health health - attack-value\n      if health <= 0\n      [\n        die\n     ]\n  ]\n  ]\n\nend","success":true}}
, {"event":"stop","timeStamp":"2024-04-19 10:40:10.962"}
]